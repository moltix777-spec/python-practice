# 📘 함수 문제 풀이 & 피드백 (1~5번)

```text
📝 문제 1. 1부터 n까지 합
- 풀이: sum(range(1, n+1)) → 파이써닉하게 해결.
- 개선: 수학 공식 n*(n+1)//2 쓰면 O(1).
- 핵심: 누적합 패턴 → 내장 함수/공식으로 최적화 가능.

📝 문제 2. 리스트 최대·최소
- 내장함수 버전: (max(nums), min(nums)) → 1줄 완성.
- 반복문 버전: mx, mn = nums[0], nums[0] → 순회하며 갱신.
- 핵심: 내장함수로 짧게 vs 직접 구현으로 로직 훈련.

📝 문제 3. 이름 포맷팅
- 요구사항: "Last, First" 형식으로 반환, upper=True 옵션 시 대문자 변환.
- 풀이:
  formatted = f"{last}, {first}"
  if upper: formatted = formatted.upper()
  return formatted
- 핵심: 기본 매개변수 + 조건 분기로 출력 옵션 제어.

📝 문제 4. 문자열 모음 개수 세기
- 직관 풀이: s.lower().count('a') + ... 식으로 합산.
- 로직 풀이:
  for ch in s.lower():
      if ch in "aeiou": count += 1
- 핵심: count 내장함수 = 내부에 이미 for+if 있음 → 내가 직접 구현 가능.

📝 문제 5. 쿠폰 할인
- 초기 실수: if coupons == "S10": → ❌ (튜플 vs 문자열 비교).
- 올바른 구조:
  for c in coupons:
      if c == "S10": result *= 0.9
      if c == "S20": result *= 0.8
      if c == "M1000": result -= 1000
- 핵심: 쿠폰은 중복 가능 → if/if/if로 독립 적용.
- 교훈: 조건문 10번(영화요금)과 같은 원리.

📌 핵심 정리 (1~5번)
- 누적합/최대최소 → 내장 함수와 직접 구현 둘 다 감각 잡기.
- 기본 매개변수 → 옵션 인자 제어 패턴 익히기.
- 내장 함수 vs 직접 로직 → 본질은 같음, 상황에 따라 선택.
- 조건문 구조 → 독립 적용은 if/if/if, 배타적 조건은 if/elif/else.
- 실행 흐름 검증 습관 → 직접 결과 비교하며 오류 캐치가 제일 중요.
